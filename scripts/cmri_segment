#!python
"""For segmenting."""

import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

import cmri.utils as utils
import cmri.roi as roi

from dipy.io.image import load_nifti, save_nifti
from dipy.io import read_bvals_bvecs
from dipy.core.gradients import gradient_table
from dipy.viz import window, actor, fury
from dipy.data import get_sphere
from dipy.reconst.dti import color_fa


def main(args):

    # set filename
    flnm = utils.Filename(args.filename, "", args.ext)

    # load tensor results
    if args.tensors is not None:
        evecs, _ = load_nifti(flnm.new("evecs"))
        evals, _ = load_nifti(flnm.new("evals"))
        evals = np.expand_dims(evals, axis=2)
        evecs = np.expand_dims(evecs, axis=2)

    # setup list of dictionaries for colors
    #['fa', 'md', 's0', 'ha', 'hap', 'ia', 'ta', 'aa', 'e2a']
    scalar_dict = [{} for c in args.color] 
    for cc, c in enumerate(args.color):
        scalar, affine = load_nifti(flnm.new(c))
        scalar_dict[cc]["name"] = c
        scalar_dict[cc]["values"] = scalar

    # masks
    if args.maskfile is not None:
        mask, _ = load_nifti(args.maskfile)
        x1, x2, y1, y2 = roi.square_from_mask(mask, return_indices=True)

        if args.tensors is not None:
            evecs, evals = evecs[x1:x2, y1:y2], evals[x1:x2, y1:y2]

        for idx in range(len(scalar_dict)):
            scalar_dict[idx]["values"] = scalar_dict[idx]["values"][x1:x2, y1:y2]

    # epi/endo surface segmentation
    if args.surf:

        # call segmentation GUI
        if args.tensors is False:
            seg_mask = roi.Segment_surfs(scalar_dict).run()
        else:
            seg_mask = roi.Segment_surfs(scalar_dict, evecs, evals).run()

        # account for original mask (used to crop image before plotting)
        if args.maskfile is not None:
            seg_mask = np.pad(seg_mask, [(x1, mask.shape[0]-x2), (y1, mask.shape[1]-y2)])

        # save mask
        save_nifti(flnm.new("seg"), seg_mask.astype(int), affine)

    # AHA model segmentation
    if args.aha is not None:

        seg = 6 if args.aha in ["base", "mid"] else 4

        # call segmentation GUI
        if args.tensors is False:
            labels = roi.Segment_aha(scalar_dict).run(seg)
        else:
            labels = roi.Segment_aha(scalar_dict, evecs, evals).run(seg)
    
        # adjust labels
        if args.aha == "base":
            pass
        if args.aha == "mid":
            labels = labels + 6
        if args.aha == "api":
            labels = labels + 12

        im = plt.imshow(labels.T, cmap="turbo")
        plt.colorbar(im)
        plt.show()

        # save a label map
        save_nifti(flnm.new("aha"), labels.astype(int), affine)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description = "Plot contents of NIfTI files.") 

    parser.add_argument("-f", "--filename", type = str, required = True,
                        help = "Name of NIFTI file used for color")

    parser.add_argument("-e", "--ext", type = str, required = False, default = "nii",
                        choices = ["nii", "nii.gz"], help = "Extension for saved files")

    parser.add_argument("-c", "--color", type = str, nargs = "+", required = True, default = None,
                        help = "List of colors, used to load --filename_\"color\".--ext for plotting")

    parser.add_argument("-t", "--tensors", required = False, default = False,
                        action = "store_true", help = "Plot using tensors")

    parser.add_argument("--surf", required = False, default = False,
                        action = "store_true", help = "Segment surfaces")

    parser.add_argument("--aha", type = str, required = False, default = None,
                        choices = ["base", "mid", "api"], help = "Segment AHA model")

    parser.add_argument("-m", "--maskfile", type = str, required = False,
                        default = None, help = "Use a mask when identifying outliers")

    #parser.add_argument("--eigen", required = False, type = str, default = None,
    #                    help = "Base name of evecs and evals files")

    #parser.add_argument("-seg", "--segment", required = False, default = False,
    #                    action = "store_true", help = "Segmentation.")

    args = parser.parse_args()

    main(args)

